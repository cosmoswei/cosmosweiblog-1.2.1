/*
SQLyog Ultimate v13.1.1 (64 bit)
MySQL - 8.0.24 : Database - blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`blog` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `blog`;

/*Table structure for table `blog_blog` */

DROP TABLE IF EXISTS `blog_blog`;

CREATE TABLE `blog_blog` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(20) COLLATE utf8mb4_general_ci NOT NULL,
  `author` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '宇宙伟',
  `content` longtext COLLATE utf8mb4_general_ci NOT NULL,
  `is_delete` int NOT NULL DEFAULT '0',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=236 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='博客';

/*Data for the table `blog_blog` */

insert  into `blog_blog`(`id`,`title`,`author`,`content`,`is_delete`,`create_time`,`update_time`) values 
(1,'Sping5','宇宙伟','### 一，加载Spring的三种方式：\n\n1. XML加载。\n2. 注解加载。\n3. 自动装配\n\n### 二，Spring 创建对象的方式：\n\n1. 无参构造创建\n\n2. 有参构造创建：\n\n   i，下标赋值。\n\n   ii，类型赋值。\n\n   iii，参数名赋值。\n\n### 三，Spring 配置\n\n#### 1，别名\n\n#### 2，Bean配置\n\n#### 3，Import\n\n### 四，注入方式（创建方式）\n\n#### 1，构造器注入\n\n​	在第二标题查看\n\n#### 2，set注入（DI）\n\n##### （1）常用类型注入\n\n1. String\n2. 自定义类型\n\n##### （2）复杂类型注入\n\n	1. 数组\n\n  2. map\n  3. list\n  4. set\n  5. null\n  6. properties\n\n##### （3）基本类型注入？\n\n#### 3，拓展方式注入\n\n1. c 命名空间注入（构造器（constructor）注入）\n2. p 命名空间注入（属性(property)注入）\n\n### 五，bean 作用域：scope 配置\n\n### 六，自动装配 autowird配置\n\n### 七，注解实现自动装配@Configuration\n\n### 八，静态代理\n\n### 九，动态代理\n\n**使用反射机制实现**\n\n#### 动态代理的好处\n\n- 可以使真实角色操作更加纯粹，不用去关注一些公共的业务。\n- 公共业务也交给代理角色，实现了业务的分工。\n- 公共业务发生拓展的时候，方便集中管理。\n- 一个动态代理类代理的是一个接口。一般就是对应的一类业务。\n- 一个动态代理可以代理多个类，只要实现了同一个接口即可。\n\n### 十，代理模式：AOP的底层实现。\n\n在加业务的时候，禁止改变原有代码，使用代理模式，加一层代理实现拓展业务。\n\n### 十一，整合MyBatis\n\n### 十二，声明式事务\n\n1. **简述**\n   	在声明式的事务处理中，要配置一个切面，其中就用到了propagation，表示打算对这些方法怎么使用事务，是用还是不用，其中propagation有七种配置，REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。默认是REQUIRED。\n\n2. **Spring中七种Propagation类的事务属性详解：**\n\n   REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 \n\n   SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 \n\n   MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。 \n\n   REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 \n\n   NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 \n\n   NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 \n\n   NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。\n\n3. **注意事项**\n   这些配置将影响数据存储，必须根据情况选择。\n\n',0,'2021-09-24 17:19:15','2021-09-24 18:10:23'),
(2,'SpringMVC','宇宙伟','# 1 SpringMVC\n\n\n\nssm：mybatis+Sping+SpringMVC    MVC三层架构\n\n\n\nJavaSE:\n\nJavaWeb:\n\nSSM框架：研究官方文档，锻炼自习能力，锻炼笔记能力，锻炼项目能力。\n\nSpringMVC+Vue+SpringBoot+SpringCloud+Linux\n\n\n\nSping :IOC与AOP\n\nSpringMVC：SpringMVC的执行流程。\n\nSpringMVC：SSM框架整合。\n\n\n\nMVC：模型（dao,service）视图（jasp,html）控制器（servlet）\n\n(MVVM 对比学习)\n\n\n\n特点：\n\n轻量级 简单易学。\n\n高效，基于请求响应的MVC框架。\n\n与Spring兼容性好,无缝结合。\n\n约定大于配置。\n\n功能强大，：RESTful,数据验证，格式化，本地化，主题。\n\n简洁灵活。\n\n***\n\n## 1.1排错\n\n### 1.1.1 SpringMVC可能会遇到404问题（项目不存在），排查步骤：\n\n1. 查看控制台输出，看是否缺少了什么jar包。\n\n2. 如果包存在，显示无法=输出，加在IDEA得项目发布中，添加lib依赖\n\n   - 项目结构>>Artifacts>>选择项目>>查看是否存在lib目录。\n\n   - 没有则在WEN-INF下添加lib文件夹（空）。\n\n   - 导入所有包。\n\n   如\n\n3. 重启Tomcat即可解决。\n\n***\n\n\n\n###  1.1.2 SpringMVC可能会遇到500问题 (1)\n\nServlet[springmvc]的Servlet.init（）引发异常\n\n没用关联spring配置文件\n\n排查方法：\n\n```xml\n<param-value>classpath:springmvc-servlet.xml</param-value>\n```\n\n\n\n### 1.1.3 SpringMVC可能会遇到500问题 (2)\n\n Servlet[springMVC]的Servlet.init（）引发异常\n\n原因是同时实例化了hello2与hello3(还不知道是什么原因)\n\n但是删掉一个或者改ReqMapp的值就好了\n\n程序正常运行。\n\n***\n\n\n\n## 1.2 SpringMVC执行原理图\n\n**在SpringMVC中 / 与/*的区别**\n\n/   只匹配所有的请求，不会去匹配jsp页面。\n\n/* 匹配所有请求，包括jsp页面。\n\n\n\n***\n\n## 1.3 RESTful 风格 (高效 简洁 安全)\n\n通过不同的**请求方式**实现不同的效果。\n\n默认为 Get\n\n​            Post\n\n​            Delete\n\n​            Patch\n\n​            Put\n\n报错解析（404）:\n\n```jsp\n<html>\n<head>\n    <title>a_jsp</title>\n</head>\n<body>\n<form action=\"/add/1/1\" method=\"post\">\n    <input type=\"submit\">\n</form>\n</body>\n</html>\n\n```\n\n报错表现：\n\n   点击提交后会跳转到8080地址，无法跳转到项目名地址找不到 a.jsp文件。\n\n解决方法：\n\n1. 去掉Tomcat服务器中的项目发布名就可以解决了，但会出现其他报错（不推荐）\n\n2. 暂时无.\n\n   \n\n***\n\n## 1.4 Model ，ModelAndView, ModelMap\n\n\n\nModelAndView：返回数据与视图（不确定）。\n\nMadel ：简版ModelMap 。\n\nModelMap：实现了LinkedHashMap接口，有LinkedHashMap全部功能。\n\nLinkedHashMap\n\n\n\n***\n\n\n\n## 1.5 乱码问题\n\n### 1.5.1 HttpServletRequest解决\n\n### 1.5.2 过滤器解决\n\n#### 1.5.2.1自己写一个过滤器\n\nEncodingFilter.java\n\n```java\npackage com.wei.filter;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class EncodingFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        servletRequest.setCharacterEncoding(\"utf-8\");\n        servletResponse.setCharacterEncoding(\"utf-8\");\n        filterChain.doFilter(servletRequest, servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n增加web.xml文件\n\n```xml\n<filter>\n    <filter-name>encoding</filter-name>\n    <filter-class>com.wei.filter.EncodingFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>encoding</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\nPOST与GET提交方式的不同也会产生乱码\n\n\n\n#### 1.5.2.2 SpringMVC自带过滤器\n\n 增加web.xml文件   \n\n```xml\n<filter>\n    <filter-name>encoding</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>encoding</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n   \n\n\n\n#### 1.5.2.3 大神写的进阶过滤器\n\n GenericEncodingFilter.java\n\n   ```java\npackage com.wei.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Map;\n\n/**\n * 解决get和post请求 全部乱码的过滤器\n */\npublic class GenericEncodingFilter implements Filter {\n\n    @Override\n    public void destroy() {\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        //处理response的字符编码\n        HttpServletResponse myResponse = (HttpServletResponse) response;\n        myResponse.setContentType(\"text/html;charset=UTF-8\");\n\n        // 转型为与协议相关对象\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        // 对request包装增强\n        HttpServletRequest myrequest = new MyRequest(httpServletRequest);\n        chain.doFilter(myrequest, response);\n    }\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n}\n\n//自定义request对象，HttpServletRequest的包装类\nclass MyRequest extends HttpServletRequestWrapper {\n\n    private HttpServletRequest request;\n    //是否编码的标记\n    private boolean hasEncode;\n\n    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰\n    public MyRequest(HttpServletRequest request) {\n        super(request);// super必须写\n        this.request = request;\n    }\n\n    // 对需要增强方法 进行覆盖\n    @Override\n    public Map getParameterMap() {\n        // 先获得请求方式\n        String method = request.getMethod();\n        if (method.equalsIgnoreCase(\"post\")) {\n            // post请求\n            try {\n                // 处理post乱码\n                request.setCharacterEncoding(\"utf-8\");\n                return request.getParameterMap();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        } else if (method.equalsIgnoreCase(\"get\")) {\n            // get请求\n            Map<String, String[]> parameterMap = request.getParameterMap();\n            if (!hasEncode) { // 确保get手动编码逻辑只运行一次\n                for (String parameterName : parameterMap.keySet()) {\n                    String[] values = parameterMap.get(parameterName);\n                    if (values != null) {\n                        for (int i = 0; i < values.length; i++) {\n                            try {\n                                // 处理get乱码\n                                values[i] = new String(values[i]\n                                        .getBytes(\"ISO-8859-1\"), \"utf-8\");\n                            } catch (UnsupportedEncodingException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    }\n                }\n                hasEncode = true;\n            }\n            return parameterMap;\n        }\n        return super.getParameterMap();\n    }\n\n    //取一个值\n    @Override\n    public String getParameter(String name) {\n        Map<String, String[]> parameterMap = getParameterMap();\n        String[] values = parameterMap.get(name);\n        if (values == null) {\n            return null;\n        }\n        return values[0]; // 取回参数的第一个值\n    }\n\n    //取所有值\n    @Override\n    public String[] getParameterValues(String name) {\n        Map<String, String[]> parameterMap = getParameterMap();\n        String[] values = parameterMap.get(name);\n        return values;\n    }\n}\n   ```\n\n  **注意配置文件中扫描的/与/*问题**\n\n***\n\n\n\n## 1.6 JSON (JavaScript Object Notation )数据交换语言\n\n前后端分离时代\n\n后端部署后端，提供接口。\n\n**JSON**\n\n前端独立部署，负责渲染后端数据。\n\n\n\nJSON：纯文本格式字符产\n\nJSON与JavaScript**对象**相互转换\n\n```html\nvar json = JSON.stringify(user)\n\nvar object = JSON.parse(json);\n```\n\n两个依赖\n\n### 1.6.1 jackson\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.12.1</version>\n</dependency>\n```\n\n### 1.6.2 fastjson (阿里巴巴的JSON数据转化包)\n\n```xml\n<dependency>    <groupId>com.alibaba</groupId>    <artifactId>fastjson</artifactId>    <version>1.2.68</version></dependency>\n```\n\n# 2 复习-1\n\n2.1 @RestController与@Controller的区别\n	@RestController不会被视图解析器解析，只返回JSON字符串\n\n\n\n\n\n？',0,'2021-09-24 17:20:39','2021-09-24 18:10:22'),
(3,'Spring Boot','宇宙伟','# SpringBoot\n\n## 原理初探：\n\n### pom.xml\n\n- spring-boot-dependencies:核心在父工程中。\n- 我们在写入或者引入一些springboot依赖时。不需要指定版本，就是因为有这些版本仓库。\n\n***\n\n\n\n### 启动器\n\n```xml\n<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n</dependency>\n```\n\n- 启动器：就是spring boot的启动场景。\n- 比如spring-boot-starter-web,他会帮我们自动导入web环境所有依赖。\n- spring boot会将所有功能场景变成启动器，如果要使用什么功能，只需要找到对应的启动器就可以了。\n\n***\n\n\n\n### 主程序:\n\n#### @SpringBootApplication\n\n```java\n@SpringBootConfiguration ： spring boot的配置\n    @Configuration ： spring配置类\n    	@Component ： 说明这也是个spring组件\n@EnableAutoConfiguration : 自动配置\n    @AutoConfigurationPackage ： 自动配置包\n    	@Import({Registrar.class}) ： 导入选择器‘自动配置包注册’\n    @Import({AutoConfigurationImportSelector.class})：自动导入选择\n\n//获取所有配置\nList<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);\n```\n\n获取候选的配置\n\n```java\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n    Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n    return configurations;\n}\n```\n\n\n\n结论：springboot所有的自动配置都是在启动时扫描并加载：\n\nspring.factories所有的自动配置类都在里面，但是不一定生效，要判断条件是否成立，只要导入了对应的starter，就有对应的启动器了，自动装配才会生效，然后就配置成功了！\n\n\n\n过程：\n\n1. springboot在启动的时候，在类路径下/META-INF/spring.factories获取指定的值。\n2. 将这些自动配置的类导入容器，自动配置的类就会生效帮我们进行自动配置。\n3. 以前我们需要自动配置的东西，现在springboot帮我们做了。\n4. 整个JavaEE，解决方案和自动配置都在spring-boot-autoconfigure\\2.4.4\\spring-boot-autoconfigure-2.4.4.jar这个包下。\n5. 他会把所有需要的组件，以类名的方式返回，这些组件就会被添加容器。\n6. 容器中会存在非常多的xxxautoConfiguration文件，就是这些类给容器中导入了这个场景所需组件，并自动配置，@Configuration\n7. 有了这些配置的类，就免去了手动编写的配置文件工作。\n\n***\n\n\n\n## SpringBoot配置文件可以配置那些东西\n\n\n\n点去默认配置文件中查看\n\n要用使用启动器（starter）\n\n\n\n***\n\n\n\n## 谈谈你对Spring Boot的理解\n\n1. 自动装配\n2. run() 方法\n\n***\n\n\n\n## springboot web开发\n\njar：webapp\n\n\n\n自动装配\n\nspringboot到底帮我们配置了什么，我们能不能进行修改，能修改拿那些东西，能不能拓展？\n\n- xxxAutoConfiguration:向容器中自动配置组件\n- xxxProperties:自动配置类，装配配置文件中自定义的一些内容\n\n\n\n要解决的问题\n\n1. 导入静态资源\n2. 首页 图标\n3. jsp,模板引擎Thymeleaf\n4. 装配扩展springmvc\n5. 增删改查\n6. 拦截器\n7. 国际化\n\n\n\n### 1，静态资源\n\n什么是webjars\n\n从那些路径导入\n\nlocalhost:8080/webjars/\n\n\n\npublic\n\nstatic\n\nresources\n\n../resources\n\n\n\n优先级：resources > static(默认) > public\n\n**如果自定义了路径。则上述的路径失效**\n\n***\n\n\n\n### 2，首页与图标\n\n首页可以放在静态资源目录下\n\n\n\n首页：\n\n```java\n//在templates目录下的页面，只能通过Controller跳转,需要模板引擎（thymeleaf）的支持\n```\n\n图标\n\n在网页中添加\n\n```html\n<head>\n    <link rel=\"icon\" href=\"1.png\">\n</head>\n```\n\n注意点：\n\n- 图标尺寸不能太大？\n- 图标像素不能太大？\n\n***\n\n\n\n### 3，模板引擎thymeleaf\n\n结论：\n\n使用thymeleaf，只需要导入对应的依赖就行了，将html放在templates目录下  line 42 ^\n\n```java\npublic static final String DEFAULT_PREFIX = \"classpath:/templates/\";\n\npublic static final String DEFAULT_SUFFIX = \".html\";\n```\n\n***\n\n\n\n### 4，拓展SpringMVC\n\n```java\npackage com.wei.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.View;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\nimport java.util.Locale;\n\n//拓展SpringMVC,如果想拓展一些自定义功能，只需要写这个组件，然后交给SpringBoot，SpringBoot就会自动装配给我\n@Configuration\npublic class MyMVCConfig implements WebMvcConfigurer {\n    //ViewResolver实现了视图解析器接口的类可以看作视图解析器\n\n    @Bean\n    public ViewResolver MyViewResolver() {\n        return new MyViewResolver();\n    }\n\n    //自定义了一个视图解析器\n    public static class MyViewResolver implements ViewResolver {\n        @Override\n        public View resolveViewName(String viewName, Locale locale) throws Exception {\n            return null;\n        }\n    }		\n}\n```\n\n\n\n如果要拓展SpringMVC，官方建议我们这么做。\n\n```java\npackage com.wei.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class MyMVCConfig implements WebMvcConfigurer {\n    //视图跳转\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/wei\").setViewName(\"test\");\n    }\n}\n```\n\n**注意！！通过这样跳转的视图不能加载Thymleaf数据！！！因为本来就没有进Controller，也就没有携带数据**\n\n\n\n不能加上**@EnableWebMvc**\n\nEnableWebMvc导入了一个类：**DelegatingWebMvcConfiguration**（获取容器中所有的webmvcconfig）\n\n```java\n@Configuration(proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {	private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();	@Autowired(required = false)	public void setConfigurers(List<WebMvcConfigurer> configurers) {		if (!CollectionUtils.isEmpty(configurers)) {			this.configurers.addWebMvcConfigurers(configurers);		}	}\n```\n\nDelegatingWebMvcConfiguration extends **WebMvcConfigurationSupport **  继承了一个类\n\n![image-20210327163510101](C:\\Users\\cosmoswei\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210327163510101.png)\n\n头部注释中标记了不能有这个类**WebMvcConfigurationSupport **  \n\n如果有这个类，配置不生效。\n\n***\n\n\n\n**自研starter？**\n\n1.  configuration\n2.  properties\n3.  放入一个jar包中。\n\n**在SpringBoot中，有非常多的xxxConfigurtion，帮助我们拓展配置，只要看见了这个东西，就要注意拓展了什么功能。**\n\n',0,'2021-09-22 20:44:22','2021-09-24 18:11:22'),
(4,'springSecurity+Shiro','宇宙伟','**认证：authentication** \n\n**授权：authorization**\n\n**过滤器拦截器**\n\n**简化变成框架**\n\n# 1. Spring Security\n\n@EnableXXXX：开启某功能\n\n@EnableWebSecurity：开启 WebSecurity 模式\n\n1. 导入依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n\n2. 配置文件:\n\n```java\npackage com.wei.config;\n\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    //授权\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //首页所有人可以访问\n        //功能页有权限的人才可以访问\n        http.authorizeRequests()\n            .antMatchers(\"/\").permitAll()\n            .antMatchers(\"/level1/**\").hasRole(\"vip1\")\n            .antMatchers(\"/level2/**\").hasRole(\"vip2\")\n            .antMatchers(\"/level3/**\").hasRole(\"vip3\");\n\n        //没有权限会自动跳转到登录页,需要开启的登录页面\n        //定制登入页面，需一一对应\n        http.formLogin().loginPage(\"/toLogin\")\n            .usernameParameter(\"user\")\n            .passwordParameter(\"pwd\")\n            .loginProcessingUrl(\"/login\");\n        //注销\n        //注销成功去首页\n        http.logout().logoutSuccessUrl(\"/\");\n        //关闭CSRF功能\n        http.csrf().disable();\n        //记住我功能，用Cookie实现,自定义接收前端参数\n        http.rememberMe().rememberMeParameter(\"remember\");\n    }\n\n    //密码编码加密：在Spring Security 5+中，新增了许多加密方法。password1中标明了编码加密\n    //认证\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        //这些数据从数据库中读取\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n            .withUser(\"cosmos\").password(new BCryptPasswordEncoder().encode(\"134567\")).roles(\"vip1\", \"vip2\")\n            .and()\n            .withUser(\"wei\").password(\"123456\").roles(\"vip3\", \"vip2\")\n            .and()\n            .withUser(\"xu\").password(\"123456\").roles(\"vip3\", \"vip2\", \"vip1\");\n    }\n}\n```\n\n3. 与**Thymeleaf**整合\n   1. 导入依赖\n\n```xml\n<dependency>\n    <groupId>org.thymeleaf.extras</groupId>\n    <artifactId>thymeleaf-extras-springsecurity4</artifactId>\n    <version>3.0.4.RELEASE</version>\n</dependency>\n```\n\n​		2. 导入命名空间**sec**\n\n```html\nxmlns :sec=\"heep://thymeleaf.org/thymleaf=extras-springsecurity4\"\n```\n\n​		3. 根据不同权限显示不同组件\n\n```html\nsec:authorize=\"hashole(\'vip1\')\"\n```\n\n\n\n# 2. Apache Shiro\n\n可以在JavaSE中运行\n\n1. 导入依赖\n2. 配置文件\n3. QuikerStart\n\n```java\nSubject currentUser = SecurityUtils.getSubject();\nSession session = currentUser.getSession();\ncurrentUser.isAuthenticated()\ncurrentUser.getPrincipal() \ncurrentUser.hasRole(\"schwartz\")\ncurrentUser.isPermitted(\"lightsaber:wield\")\ncurrentUser.logout();\n```\n\n1.在SpringBoot中集成\n\n**在整合mybatis中遇到的一些问题：**\n\n1. ```xml\\\n   <select id=\"queryUserByName\" parameterType=\"String\" resultType=\"User\">\n   ```\n\n   把parameterType，resultType写成parameterMap，resultMap报错\n\n2. ```yaml\n   url: jdbc:mysql://localhost:3306/cosmos?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\n   ```\n\n   把cosmos数据库写成mybatis 直接写了以前的数据库名（复制以前代码）。这个参数是用来填数据库名的。\n\n**在授权中遇到的问题 1：**\n\n```java\n//授权filterChainDefinitionMap.put(\"/user/add\",\"perms[user:add]\");filterChainDefinitionMap.put(\"/user/updata\",\"perms[user:updata]\");//拦截filterChainDefinitionMap.put(\"/user/*\", \"authc\");\n```\n\n授权与拦截语句位置颠倒会导致拦截失败。\n\n**在授权中遇到的问题 2：**\n\n```java\nfilterChainDefinitionMap.put(\"/user/*\", \"perms[user:both]\");\n```\n\n![image-20210409162847612](C:\\Users\\cosmoswei\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210409162847612.png)\n\n无法授权两个权限\n\n解决方案：两次授权\n\n```java\nfilterChainDefinitionMap.put(\"/user/add\", \"perms[user:both]\");filterChainDefinitionMap.put(\"/user/updata\", \"perms[user:both]\");\n```\n\n**上述方法不可行！影响其他授权方式。**\n\n\n\n整合Thymeleaf\n\n1. 导入依赖\n2. 配置ShiroDialect\n3. 前端设置\n\n遇到的问题：\n\n1. 多重权限列表无法加载进首页\n\n2. 整合Thymeleaf后权限失效，进无权限页面。\n\n3. 发现问题：\n\n   - 多重权限不能展示权限列表但可以进权限界面\n\n   - 单一权限可以展示权限列表不能进权限界面\n\n   - 无权限展示权限列表错误不能进权限界面\n\n   问题原因：上面给cosmos两次授权造成的权限冲突，注释代码可以解决。\n\n   **但是如何解决多权限认证呢？**\n\n   \n\n   \n\n\n\n\n【优质链接】：http://www.ityouknow.com/springboot/2017/06/26/spring-boot-shiro.html',0,'2021-09-24 17:20:52','2021-09-24 18:11:22'),
(5,'Spring Cloud','宇宙伟','CAP原则：\n\n**为什么分布式环境下CAP三者不可兼得呢？**\n\n​    由于上面已经提到对于分布式环境下，P是必须要有的，所以该问题可以转化为：如果P已经得到，那么C和A是否可以兼得？可以分为两种情况来进行推演：\n\n​    (1) 如果在这个分布式系统中数据没有副本，那么系统必然满足强一致性条件，因为只有独本数据，不会出现数据不一致的问题，此时C和P都具备。但是如果某些服务\n\n器宕机，那必然会导致某些数据是不能访问的，那A就不符合了。\n\n​    (2) 如果在这个分布式系统中数据是有副本的，那么如果某些服务器宕机时，系统还是可以提供服务的，即符合A。但是很难保证数据的一致性，因为宕机的时候，可能有些数据还没有拷贝到副本中，那么副本中提供的数据就不准确了。\n\n​    所以一般情况下，会根据具体业务来侧重于C或者A，对于一致性要求比较高的业务，那么对访问延迟时间要求就会低点；对于访问延时有要求的业务，那么对于数据一致性要求就会低点。一致性模型主要可以分为下面几类：强一致性、弱一致性、最终一致性、因果一致性、读你所写一致性、会话一致性、单调读一致性、以及单调写一致性，所以需要根据不同的业务选择合适的一致性模型。\n\n\n\nRPC 对比 RESTfull\n\n**RPC**：\n\n服务提供者去注册中心（ZooKeeper）注册服务，服务消费者去注册中心（ZooKeeper）调用服务。\n\n**RESTfull**：\n\n服务提供者只需要生产服务，服务消费者通过目标地址（restTemmlete）来调用服务，\n\n类似于转发？\n\n\n\n**Dubbo 2.7.10 是个坑比版本！2.7.7才可以用！**\n\n\n\n一， Eureka:\n\n1，导入依赖\n\n2，配置文件\n\n3，@EnableEurekaServer\n\n二，Ribbon：客户端负载均衡工具，调用微服务方式：微服务名字\n\n1，导入依赖\n\n2，配置文件\n\n3，@EnableXXXX\n\n三，Feign：服务端负载均衡工具，调用微服务方式：接口和注解，集成了 Ribbon\n\n四，Hystrix：服务雪崩，服务熔断，服务降级\n\n五，Zuul：代理，路由，过滤\n\n六，Config\n\n​	1，GIT：上传到远程仓库\n\n​	2，远程仓库：分布式配置配置文件\n\n​	3，Config 服务端：去远程仓库拉取配置文件\n\n​	4，Config 客户端：去Cinfig客户端拉取配置文件\n\n​	4，5，需要**导入** SpringCloud Config 依赖，**开启** EnableXXX 注解，**编写** Config 配置文件\n\n微服务技术栈版本匹配问题',0,'2021-09-22 20:48:39','2021-09-24 18:12:02'),
(6,'HTTP状态码','宇宙伟','# HTTP状态码\n\n当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。\n\nHTTP状态码的英文为HTTP Status Code。\n\n下面是常见的HTTP状态码：\n\n- 200 - 请求成功\n- 301 - 资源（网页等）被永久转移到其它URL\n- 404 - 请求的资源（网页等）不存在\n- 500 - 内部服务器错误\n\n# HTTP状态码分类\n\nHTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\n\n| 分类 | 分类描述                                       |\n| :--- | :--------------------------------------------- |\n| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |\n| 2**  | 成功，操作被成功接收并处理                     |\n| 3**  | 重定向，需要进一步的操作以完成请求             |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\n\nHTTP状态码列表:\n\n| 状态码 | 状态码英文名称                  | 中文描述                                                     |\n| :----- | :------------------------------ | :----------------------------------------------------------- |\n| 100    | Continue                        | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |\n| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |\n|        |                                 |                                                              |\n| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |\n| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |\n| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |\n| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |\n| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |\n| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |\n| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |\n|        |                                 |                                                              |\n| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |\n| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |\n| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |\n| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |\n| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |\n| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |\n|        |                                 |                                                              |\n| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |\n| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |\n| 402    | Payment Required                | 保留，将来使用                                               |\n| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |\n| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 |\n| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |\n| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |\n| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |\n| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |\n| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |\n| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |\n| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |\n| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |\n| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |\n| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |\n| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |\n| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |\n| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |\n|        |                                 |                                                              |\n| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |\n| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |\n| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |\n| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |\n| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |\n| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |',0,'2021-09-24 08:37:12','2021-09-24 18:11:38'),
(7,'JDK历史','朱小厮','# 一部全网最全的 JDK 发展历史轨迹图\n\n![img](https://account.itpub.net/api/avatar.php?uid=69940568) [朱小厮的博客](http://www.itpub.net/author/69940568/) 2020-03-03 10:08:51 本文共4482个字，预计阅读需要12分钟。\n\nJava语言的相关组织和规范（其他语言也有类似的组织）：\n\n- JCP：（Java Community Process）由世界上各个为 Java 发展操心的人士组成的社区，参与 定义 Java 新特性和新版本制定标准的组织。\n- JSR：（Java Specification Requests）Java 语言规范请求文档，你可以对 Java 提出新的要求，然后 Java 相关的组织投票决定是否通过，通过后就将这个要求写入 JSR 中，并且最终给出一个开源的实现。\n- JEP：（Java Enhancement Proposal），Java 增强建议，收集大家对于 JDK 的建议，起草增强 Java 哪些功能的方案，为 JDK 新版本发布及相关工作指定路线。\n\n## JAVA 1.0 ,代号Oak（橡树）\n\n于1996-01-23发行\n\n## JAVA 1.1\n\n1997-02-19发行,主要更新内容:\n\n1. 引入JDBC\n2. 添加内部类支持\n3. 引入JAVA BEAN\n4. 引入RMI\n5. 引入反射\n\n## JAVA 1.2, 代号Playground（操场）\n\n1998-12-8发行，主要更新内容：\n\n1. 引入集合框架\n2. 对字符串常量做内存映射\n3. 引入JIT（Just In Time）编译器\n4. 引入打包文件数字签名\n5. 引入控制授权访问系统资源策略工具\n6. 引入JFC（Java Foundation Classes），包括Swing1.0，拖放和Java2D类库\n7. 引入Java插件\n8. JDBC中引入可滚动结果集，BLOB,CLOB,批量更新和用户自定义类型\n9. Applet中添加声音支持\n\n## JAVA1.3，代号Kestrel（红隼）\n\n2000-5-8发布，主要更新内容：\n\n1. 引入Java Sound API\n2. 引入jar文件索引\n3. 对Java各方面多了大量优化和增强\n4. Java Platform Debugger Architecture用于 Java 调式的平台。\n\n## JAVA 1.4，代号Merlin（隼）\n\n2004-2-6发布（首次在JCP下发行），主要更新内容：\n\n1. 添加XML处理\n2. 添加Java打印服务（Java Print Service API）\n3. 引入Logging API\n4. 引入Java Web Start\n5. 引入JDBC 3.0 API\n6. 引入断言\n7. 引入Preferences API\n8. 引入链式异常处理\n9. 支持IPV6\n10. 支持正则表达式\n11. 引入Image I/O API\n12. NIO，非阻塞的 IO，优化 Java 的 IO 读取。\n\n## JDK  5.0，代号Tiger（老虎），有重大改动\n\n2004-9-30发布，主要更新内容：\n\n1. 引入泛型\n2. For-Each循环 增强循环，可使用迭代方式\n3. 自动装箱与自动拆箱\n4. 引入类型安全的枚举\n5. 引入可变参数\n6. 添加静态引入\n7. 引入注解\n8. 引入Instrumentation\n9. 提供了 java.util.concurrent 并发包。\n\n## JDK 6，代号Mustang（野马）\n\n2006-12-11发布，主要更新内容：\n\n1. 引入了一个支持脚本引擎的新框架（基于 Mozilla Rhino 的 JavaScript 脚本引擎）\n2. UI的增强\n3. 对WebService支持的增强（JAX-WS2.0 和 JAXB2.0）\n4. 引入JDBC4.0API\n5. 引入Java Compiler API\n6. 通用的Annotations支持\n\n## JDK 7，代号Dolphin（海豚）\n\n2011-07-28发布，这是sun被oracle收购（2009年4月）后的第一个版本，主要更新内容：\n\n1. switch语句块中允许以字符串作为分支条件\n2. 在创建泛型对象时应用类型推断,比如你之前版本使用泛型类型时这样写 ArrayList<User> userList= new ArrayList<User>();，这个版本只需要这样写 ArrayList<User> userList= new ArrayList<>();，也即是后面一个尖括号内的类型，JVM 帮我们自动类型判断补全了。\n3. 在一个语句块中捕获多种异常\n4. 添加try-with-resources语法支持，使用文件操作后不用再显示执行close了。\n5. 支持动态语言\n6. JSR203, NIO.2,AIO,新I/O文件系统，增加多重文件的支持、文件原始数据和符号链接,支持ZIP文件操作\n7. JDBC规范版本升级为JDBC4.1\n8. 引入Fork/Join框架，用于并行执行任务\n9. 支持带下划线的数值，如 int a = 100000000;，0 太多不便于人阅读，这个版本支持这样写 int a = 100_000_000，这样就对数值一目了然了。\n10. Swing组件增强（JLayer,Nimbus Look Feel…）参考\n\n## JDK 8\n\n2014-3-19发布，oracle原计划2013年发布，由于安全性问题两次跳票，是自JAVA5以来最具革命性的版本，主要更新内容：\n\n1. 接口改进，接口居然可以定义默认方法实现和静态方法了。\n2. 引入函数式接口\n3. 引入Lambda表达式\n4. 引入全新的Stream API，提供了对值流进行函数式操作。\n5. 引入新的Date-Time API\n6. 引入新的JavaScrpit引擎Nashorn\n7. 引入Base64类库\n8. 引入并发数组（parallel）\n9. 添加新的Java工具：jjs、jdeps\n10. JavaFX，一种用在桌面开发领域的技术\n11. 静态链接 JNI 程序库\n\n## JDK 9\n\n2017-9-21发布\n\n1. 模块化（jiqsaw）\n2. 交互式命令行（JShell）\n3. 默认垃圾回收期切换为G1\n4. 进程操作改进\n5. 竞争锁性能优化\n6. 分段代码缓存\n7. 优化字符串占用空间\n\n## JDK 10\n\n2018-3-21发布\n\n1. JEP286，var 局部变量类型推断。\n2. JEP296，将原来用 Mercurial 管理的众多 JDK 仓库代码，合并到一个仓库中，简化开发和管理过程。\n3. JEP304，统一的垃圾回收接口。\n4. JEP307，G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。\n5. JEP310，应用程序类数据 (AppCDS) 共享，通过跨进程共享通用类元数据来减少内存占用空间，和减少启动时间。\n6. JEP312，ThreadLocal 握手交互。在不进入到全局 JVM 安全点 (Safepoint) 的情况下，对线程执行回调。优化可以只停止单个线程，而不是停全部线程或一个都不停。\n7. JEP313，移除 JDK 中附带的 javah 工具。可以使用 javac -h 代替。\n8. JEP314，使用附加的 Unicode 语言标记扩展。\n9. JEP317，能将堆内存占用分配给用户指定的备用内存设备。\n10. JEP317，使用 Graal 基于 Java 的编译器，可以预先把 Java 代码编译成本地代码来提升效能。\n11. JEP318，在 OpenJDK 中提供一组默认的根证书颁发机构证书。开源目前 Oracle 提供的的 Java SE 的根证书，这样 OpenJDK 对开发人员使用起来更方便。\n12. JEP322，基于时间定义的发布版本，即上述提到的发布周期。版本号为`$FEATURE.$INTERIM.$UPDATE.$PATCH`，分别是大版本，中间版本，升级包和补丁版本。\n\n## JDK  11\n\n2018-9-25发布\n\n官网公开的 17 个 JEP（JDK Enhancement Proposal 特性增强提议）：\n\n1. JEP181: Nest-Based Access Control（基于嵌套的访问控制）\n2. JEP309: Dynamic Class-File Constants（动态的类文件常量）\n3. JEP315: Improve Aarch64 Intrinsics（改进 Aarch64 Intrinsics）\n4. JEP318: Epsilon: A No-Op Garbage Collector（Epsilon 垃圾回收器，又被称为”No-Op（无操作）”回收器）\n5. JEP320: Remove the Java EE and CORBA Modules（移除 Java EE 和 CORBA 模块，JavaFX 也已被移除）\n6. JEP321: HTTP Client (Standard)\n7. JEP323: Local-Variable Syntax for Lambda Parameters（用于 Lambda 参数的局部变量语法）\n8. JEP324: Key Agreement with Curve25519 and Curve448（采用 Curve25519 和 Curve448 算法实现的密钥协议）\n9. JEP327: Unicode 10\n10. JEP328: Flight Recorder（飞行记录仪）\n11. JEP329: ChaCha20 and Poly1305 Cryptographic Algorithms（实现 ChaCha20 和 Poly1305 加密算法）\n12. JEP330: Launch Single-File Source-Code Programs（启动单个 Java 源代码文件的程序）\n13. JEP331: Low-Overhead Heap Profiling（低开销的堆分配采样方法）\n14. JEP332: Transport Layer Security (TLS) 1.3（对 TLS 1.3 的支持）\n15. JEP333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）\n16. JEP335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）\n17. JEP336: Deprecate the Pack200 Tools and API（弃用 Pack200 工具及其 API）\n\n## JDK 12\n\n2019-3-19发布\n\n1. JEP189:Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)\n2. JEP230:Microbenchmark Suite\n3. JEP325:Switch Expressions (Preview)\n4. JEP334:JVM Constants API\n5. JEP340:One AArch64 Port, Not Two\n6. JEP341:Default CDS Archives\n7. JEP344:Abortable Mixed Collections for G1\n8. JEP346:Promptly Return Unused Committed Memory from G1\n\n## JDK 13\n\n2019-9-17 发布\n\n1. JEP350:Dynamic CDS Archives\n2. JEP351:ZGC: Uncommit Unused Memory\n3. JEP353:Reimplement the Legacy Socket API\n4. JEP354:Switch Expressions\n5. JEP355:Text Blocks\n\n## JDK 14\n\n预计2020/03/17 General Availability\n\n1. JEP 305: Pattern Matching for instanceof (Preview)\n2. JEP 358: Helpful NullPointerExceptions\n3. JEP 361: Switch Expressions (Standard)\n4. JEP 345: NUMA-Aware Memory Allocation for G1\n5. JEP 349: JFR Event Streaming\n6. JEP 366: Deprecate the ParallelScavenge + SerialOld GC Combination\n7. JEP 363: Remove the CMS Garbage Collector\n8. JEP 364: ZGC on macOS\n9. JEP 368: Text Blocks (Second Preview)\n\n原文连接：http://www.itpub.net/2020/03/03/5376/',0,'2021-09-23 21:05:45','2021-09-24 18:11:39'),
(8,'Vue学习笔记','宇宙伟','# Vue\n\nSoc：关注点分离原则\n\nHTML+CSS+JAVASCRIPT\n\n网络通信：axios\n\n页面跳转：vue-router\n\n状态管理：vuex\n\n只关心视图层\n\nvm：数据双向绑定\n\n**计算属性 ：Vue特点**\n\n前端三大框架\n\n​	1. JQuery：\n\n​	2. Angular ：前端MVC\n\n​	3. React：虚拟DOM（模拟DOC），放在内存中操作\n\nVue：集大成者（Angular ，React）\n\nAxios：前端通信框架\n\n JS构建工具：\n\n- Bable：JS编译工具\n- WebPack：模块打包工具\n\n三端统一（PC:，Android:.apk，IOS:ipa）调用硬件：GPS，陀螺仪闪光灯，相机\n\n\n\n大前端时代：MV*时代\n\nMVC（同步通信为主）：Model，View，Controller\n\nMVP（异步通信为主）：Model，View，Presenter\n\nMVVM（异步通信为主）：Model，View，View Model\n\nView Model 双向绑定层。\n\n\n\n## 1，循环-判断\n\n### 1.1 判断 ：v-if v-else-if v-else\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>VueTest</title>\n</head>\n<body>\n<div id=\"app\">\n    <h1 v-if=\"type===\'a\'\">A</h1>\n    <h1 v-else-if=\"type===\'b\'\">B</h1>\n    <h1 v-else-if=\"type===\'c\'\">C</h1>\n    <h1 v-else>in -> defghijklmnopqrstuvwxyz</h1>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    var vm = new Vue({\n        el: \"#app\",\n        data: {\n            type: \'s\'\n        }\n    })\n</script>\n</body>\n</html>\n```\n\n\n\n### 1.2 循环：v-for\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>VueTest</title>\n</head>\n<body>\n<div id=\"app\">\n    <li v-for=\"item in items\">\n        {{item.message}}\n    </li>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    var vm = new Vue({\n        el: \"#app\",\n        data: {\n            items: [\n                {message: \"宇宙伟\"},\n                {message: \"黄旭伟\"},\n                {message: \"哈哈哈\"},\n                {message: \"哈哈哈\"},\n                {message: \"哈哈哈\"},\n                {message: \"哈哈哈\"},\n                {message: \"哈哈哈\"}\n            ]\n        }\n    })\n</script>\n</body>\n</html>\n```\n\n\n\n## 2，事件处理 v-on\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Domo-04</title>\n</head>\n<body>\n<div id=\"app\">\n    <button v-on:click=\"say\">Click Me</button>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    let vm = new Vue({\n        el: \"#app\",\n        data: {\n            message: \"宇宙伟大奥秘\"\n        },\n        methods: {\n            say: function () {\n                alert(this.message)\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n\n\n## 3，视图\n\n### 3.1.，双向绑定\n\n#### 3.1.1，文本\n\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Demo-05</title>\n</head>\n<body>\n<div id=\"app\">\n    输入的文本：<input type=\"text\" v-model=\"message\">\n<!--    输入的文本：<textarea v-model=\"message\"></textarea>-->\n    <br>\n    {{message}}\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    let vm = new Vue({\n        el: \"#app\",\n        data: {\n            message: \"宇宙伟大奥秘\"\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n#### 3.1.2，下拉框\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Demo-05</title>\n</head>\n<body>\n<div id=\"app\">\n    下拉框：\n    <select v-model=\"selected\">\n        <option disabled value=\"\">请选择</option>\n        <option>A</option>\n        <option>B</option>\n        <option>C</option>\n    </select>\n    <br>\n    你选中了：{{selected}}\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    let vm = new Vue({\n        el: \"#app\",\n        data: {\n            selected: \'A\'\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n\n\n## 4，组件：自定义标签\n\n### 4.1自定义标签\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Demo-06</title>\n</head>\n<body>\n\n<div id=\"app\">\n    <wei v-for=\"item in items\" v-bind:xu=\"item\"></wei>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    \'use strict\'\n    Vue.component(\"wei\", {\n        props: [\'xu\'],\n        template: \'<li>{{xu}}</li>\'\n    })\n    var vm = new Vue({\n        el: \"#app\",\n        data: {\n            items: [\"A\", \"B\", \"C\", \"D\"]\n        }\n    })\n</script>\n</body>\n\n</html>\n```\n\n\n\n## 5，网络通信\n\nAxios：用在浏览器或Node JS的异步通信框架\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Demo-07</title>\n\n<!--解决闪烁问题-->\n    <style>\n        [v-clock] {\n            display: none;\n        }\n    </style>\n</head>\n\n<body>\n<div id=\"vue\" v-clock>\n    <div>{{info.name}}</div>\n    <div>{{info.address.country}}</div>\n    <a v-bind:href=\"info.url\">bilibiliGo</a>\n</div>\n\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script type=\"text/javascript\">\n    var vm = new Vue({\n        el: \'#vue\',\n        data() {\n            return {\n                //请求的返回参数必须和JSON字符串一样\n                info: {\n                    name: null,\n                    address: {\n                        street: null,\n                        city: null,\n                        country: null\n                    },\n                }\n            }\n        },\n        mounted() {\n            axios.get(\'../data.json\').then(response => (this.info = response.data))\n        }\n    })\n</script>\n\n</body>\n</html>\n```\n\n\n\n## 6，计算属性\n\n计算出来的结果，保存在属性中，内存中运行：虚拟DOM，可以想象成**缓存**\n\n**用属性的方式实现方法的功能**,这两者不能同名\n\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>计算属性</title>\n</head>\n\n<body>\n<div id=\"app\">\n    <p>currentTime1:{{currentTime1()}}</p> //调用方法有括号\n    <p>currentTime2:{{currentTime2}}</p> //调用属性没有括号\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    var vm = new Vue({\n        el: \"#app\",\n        data: {\n            message: \"hello cosmos\"\n        },\n        methods: {\n            currentTime1: function () {\n                return Date.now();\n            }\n        },\n        computed: {\n            currentTime2: function () {\n                return Date.now();\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n**与狂神的不同点**\n\ncurrentTime1，调用自身，调用message都刷新时间戳\n\ncurrentTime2，调用自身不刷新时间戳，调用message后刷新时间戳\n\n\n\n结论：\n\n调用方法时,每次都需要进行计算,既然有计算过程则必定产生系统开销,那如果这个结果是不经常变化的呢?此时就可以考虑将这个结果缓存起来,采用计算属性可以很方便的做到这一点。\n\n**计算属性的主要特性就是为了将不经常变化的计算结果进行缓存,以节约我们的系统开销。**\n\n\n\n## 7，内容分发\n\n### 7.1 slot:插槽：动态插拔\n\n```html\n<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>Demo-08</title><body><div id=\"vue\">    <todo>        <todo-title slot=\"todo-title\" :title=\"title\"></todo-title>        <todo-items slot=\"todo-items\" v-for=\"item in todoItems\" :item=\"item\"></todo-items>    </todo></div><script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script><script type=\"text/javascript\">    Vue.component(\"todo\", {        template: \'<div>\\                        <slot name=\"todo-title\"></slot>\\                        <ul>\\                            <slot name=\"todo-items\"></slot>\\                        </ul>\\                    </div>\'    });    Vue.component(\"todo-title\", {        props: [\'title\'],        template: \'<div>{{title}}</div>\'    })    Vue.component(\"todo-items\", {        props: [\'item\'],        template: \'<li>{{item}}</li>\'    });    var vm = new Vue({        el: \'#vue\',        data: {            title: \"java系列\",            todoItems: [\"java1\", \"java2\", \"java3\", \"java4\"]        }    });</script></body></html>\n```\n\n### 7.2 自定义事件\n\nthis.$emit(\'自定义事件\',参数)\n\n```html\n<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>Demo-08</title><body><div id=\"vue\">    <todo>        <todo-title slot=\"todo-title\" :title=\"title\"></todo-title>        <todo-items slot=\"todo-items\" v-for=\"(item,index) in todoItems\"                    :item=\"item\" v-bind:index=\"index\" v-on:remove=\"removeItems(index)\" :key=\"index\"></todo-items>    </todo></div><script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script><script type=\"text/javascript\">    Vue.component(\"todo\", {        template: \'<div>\\                        <slot name=\"todo-title\"></slot>\\                        <ul>\\                            <slot name=\"todo-items\"></slot>\\                        </ul>\\                    </div>\'    });    Vue.component(\"todo-title\", {        props: [\'title\'],        template: \'<div>{{title}}</div>\'    })    Vue.component(\"todo-items\", {        props: [\'item\', \'index\'],        template: \'<li>{{index}}---{{item}}<button @click=\"remove\">delete</button>\\n</li>\',        methods: {            remove: function (index) {                this.$emit(\'remove\', index);            }        }    });    var vm = new Vue({        el: \'#vue\',        data: {            title: \"java版本\",            todoItems: [\"java1\", \"java2\", \"java3\", \"java4\"]        },        methods: {            removeItems: function (index) {                console.log(\"delete\" + this.todoItems[index]);                this.todoItems.splice(index, 1);            }        }    });</script></body></html>\n```\n\n\n\n## 8，webpack\n\n一个因为浏览器无法兼容ES5以上版本而出现的打包工具。\n\n**hello.js**\n\n```js\nexports.sayHi = function () {    document.write(\"<h1>ES6</h1>>\")}\n```\n\n**main.js**\n\n```js\nvar hello = require(\"./hello\");hello.sayHi();\n```\n\n**webpack.config.js**\n\n```js\nmodule.exports = {    entry: \'./modules/main.js\',    output: {        filename: \"./js/bundle.js\"    }}\n```\n\nindex.html\n\n```html\n<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>webpack</title></head><body><script src=\"dist/js/bundle.js\"></script></body></html>\n```\n\n\n\n## 9，vue -router\n\n路由管理器\n\n作业于Vue的页面跳转\n\n\n\n**注意点**：需要到myvue目录下执行**npm run dev**指令\n\n\n\n一个点击运行程序后**自动下载App.vue**的问题：\n\n可能原因：因为IDEA默认跳转到http://localhost:63342/myvue/src/App.vue?_ijt=8o740dblvgol1hegogqotq85eu端口，这个端口无法自动跳转就下载了App.vue。\n\n需要手动跳转localhost:8080。\n\n暂时没有找到解决方法\n\n\n\n## 10，ElementUI+Vue\n\nlogin.vue\n\n```vue\n<template>  <div>    <el-form ref=\"loginForm\" :model=\"form\" :rules=\"rules\" label-width=\"80px\" class=\"login-box\">      <h3 class=\"login-title\">欢迎登录</h3>      <el-form-item label=\"账号\" prop=\"username\">        <el-input type=\"text\" placeholder=\"请输入账号\" v-model=\"form.username\"/>      </el-form-item>      <el-form-item label=\"密码\" prop=\"password\">        <el-input type=\"password\" placeholder=\"请输入密码\" v-model=\"form.password\"/>      </el-form-item>      <el-form-item>        <el-button type=\"primary\" v-on:click=\"onSubmit(\'loginForm\')\">登录</el-button>      </el-form-item>    </el-form>    <el-dialog      title=\"温馨提示\"      :visible.sync=\"dialogVisible\"      width=\"30%\"      :before-close=\"handleClose\">      <span>请输入账号和密码</span>      <span slot=\"footer\" class=\"dialog-footer\">        <el-button type=\"primary\" @click=\"dialogVisible = false\">确 定</el-button>      </span>    </el-dialog>  </div></template><script>export default {  name: \"Login\",  data() {    return {      form: {        username: \'\',        password: \'\'      },      //表单验证，需要再el-form-item 元素中增加prop属性      rules: {        username: [          {required: true, message: \'账号不能为空\', trigger: \'blur\'}        ],        password: [          {required: true, message: \'密码不能为空\', trigger: \'blur\'}        ]      },      //对话框显示和隐藏      dialogVisible: false    }  },  methods: {    onSubmit(formName) {      //为表单绑定验证功能      this.$refs[formName].validate((valid) => {        if (valid) {          //使用 vue-router路由到指定页面，该方式称之为编程式导航          this.$router.push(\"/main\");        } else {          this.dialogVisible = true;          return false;        }      });    }  }}</script><style lang=\"scss\" scoped>.login-box {  border: 1px solid #DCDFE6;  width: 350px;  margin: 180px auto;  padding: 35px 35px 15px 35px;  border-radius: 5px;  -webkit-border-radius: 5px;  -moz-border-radius: 5px;  box-shadow: 0 0 25px #909399;}.login-title {  text-align: center;  margin: 0 auto 40px auto;  color: #303133;}</style>\n```\n\nindex.js\n\n```js\nimport Vue from \'vue\'import Router from \'vue-router\'import Main from \'../views/Main\'import Login from \'../views/Login\'Vue.use(Router);export default new Router({  routes: [    {      path: \'/main\',      component: Main    },    {      path: \'/login\',      component: Login    }  ]});\n```\n\nmain.js\n\n```js\nimport Vue from \'vue\'import App from \'./App\'import router from \'./router\'import ElementUI from \'element-ui\';import \'element-ui/lib/theme-chalk/index.css\';Vue.use(router);Vue.use(ElementUI);new Vue({  el: \'#app\',  router,  render:h =>h(App)})\n```\n\nApp.vue\n\n```vue\n<template>  <div id=\"app\">    <router-view></router-view>  </div></template><script>export default {  name: \'App\'}</script>\n```\n\nMain.vue\n\n```vue\n<template><h1>首页</h1></template><script>export default {  name: \"Main\"}</script><style scoped></style>\n```\n\n\n\n**记得在package.json给sass降级**\n\n```json\n\"sass-loader\": \"^7.3.1\",\n```\n\n\n\n## 11,嵌套路由\n\n关键字：**children**\n\nMain.vue\n\n```vue\nimport Vue from \'vue\'import Router from \'vue-router\'import Main from \'../views/Main\'import Login from \'../views/Login\'import UserList from \'../views/user/List\'import UserProfile from \'../views/user/Profile\'Vue.use(Router);export default new Router({  routes: [    {      path: \'/main\',      component: Main,      children: [        {          path: \'/user/profile\',          component: UserProfile        },        {          path: \'/user/list\',          component: UserList        }      ]    },    {      path: \'/login\',      component: Login    }  ]});\n```\n\n\n\n## 12，参数传递\n\n### 12.1 直接传值\n\n无法传入id\n\nMain.vue\n\n```vue\n<router-link v-bind:to=\"{name:\'UserProfile\',params:{id:1}}\">个人信息</router-link>\n```\n\nindex.js\n\n```js\npath: \'/user/profile/:id\',name: UserProfile,component: UserProfile\n```\n\n目前**没有解决**\n\n### 12.2 props:解耦\n\n\n\n## 13，重定向:redirect\n\n```vue\n{  path:\'/goHome\',  redirect:\'/main\'}\n```\n\n\n\n## 14，路由钩子与异步请求\n\n### 14.1 路由钩子：\n\n```vue\nbeforeRouteEnter: (to, from, next) => {	console.log(\"进入路由\");	next();},beforeRouteLeave: (to, from, next) => {	console.log(\"离开路由\");next();},beforeRouteUpdate: (to, from, next) => {	}\n```\n\n- to：路由将要跳转的路径信息\n\n- from：路由跳转前的路径信息\n\n- next：路由的控制参数\n\n1. next()：跳转到下一个页面\n2. next(\'/path\')：改变路由的跳转方向，跳到另一个路由\n3. next(\'false\')：返回原来的页面\n4. next((vm)=>{})：仅在beforeRouteEnter中可用，vn是组件实例。\n\n### 14.2 在钩子函数中使用异步请求\n\n记得在mian.js导入Axios模块\n\n```js\nimport axios from \'axios\';import VueAxios from \'vue-axios\';Vue.use(VueAxios,axios);\n```\n\nProfile.vue中axios部分\n\n```vue\nmethods: {    getData: function () {      this.axios({        method: \'get\',        url: \"http://localhost:8080/static/mock/data.json\"      }).then(function (response) {        console.log(response)      })    }  }\n```\n\n## 15 Vue2 与Vue3 安装对比\n\n| Vue2                                            | Vue3                        |\n| :---------------------------------------------- | :-------------------------- |\n| 在vue目录下                                     | 在vue目录下                 |\n| **1，vue init webpack hello-vue**               | **1，vue create hello-vue** |\n| **2，cd hello-vue**                             | **2，cd hello-vue**         |\n| 3，安装插件：vue install vue router --save -dev |                             |\n| 4，安装 elment ui ，sass-loader                 |                             |\n| **5，npm run dev**                              | **5，npm run server**       |\n|                                                 |                             |\n\nVue2，Vue3 响应式数据对比：\n\nVue2：\n\n```vue\nexport default {  /* 在Vue3中依然可以使用data和methods配置, 但建议使用其新语法实现 */   data () {     return {       count: 0     }   },   methods: {     update () {       this.count++     }   }}\n```\n\nVue3：\n\n```vue\nexport default {  /* 使用vue3的composition API */  setup () {    // 定义响应式数据 ref对象    const count = ref(1)    // 更新响应式数据的函数    function update () {      count.value = count.value + 1    }    return {      count,      update    }  }}\n```\n\n\n\n## 17，VueX五个核心：\n\n**1，state**\n\n管理数据\n\n**2，getter**\n\n获得数据\n\n**3，mutation**\n\n修改数据\n\n**4，action**\n\n执行修改\n\n**5，module**\n\n分块',0,'2021-09-24 08:49:51','2021-09-24 18:11:38'),
(235,'123','123','123',0,'2021-09-25 21:03:52','2021-09-25 21:03:52');

/*Table structure for table `blog_book` */

DROP TABLE IF EXISTS `blog_book`;

CREATE TABLE `blog_book` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `author` varchar(20) COLLATE utf8mb4_general_ci NOT NULL,
  `press` varchar(20) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `ISBN` varchar(30) COLLATE utf8mb4_general_ci NOT NULL DEFAULT '978-7-111-11111-1',
  `path` varchar(30) COLLATE utf8mb4_general_ci NOT NULL DEFAULT '/workspace/blog/book/',
  `is_delete` int NOT NULL DEFAULT '0',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='书籍';

/*Data for the table `blog_book` */

insert  into `blog_book`(`id`,`title`,`author`,`press`,`ISBN`,`path`,`is_delete`,`create_time`,`update_time`) values 
(1,'深入理解计算机系统','兰德尔 E.布莱恩特','机械工业出版社','113-456-789','/workspace/blog/book/',0,'2021-09-22 21:16:45','2021-09-26 14:28:08'),
(5,'AIoT物联网开发实战（上）','阿里巴巴','阿里巴巴','123','/workspace/blog/book/',0,'2021-09-25 14:06:17','2021-09-26 14:28:08'),
(6,'AIoT物联网开发实战（下）','阿里巴巴','阿里巴巴','978-7-111-11111-1','/workspace/blog/book/',0,'2021-09-25 14:11:28','2021-09-26 14:28:08');

/*Table structure for table `blog_user` */

DROP TABLE IF EXISTS `blog_user`;

CREATE TABLE `blog_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `phone` varchar(20) COLLATE utf8mb4_general_ci NOT NULL,
  `email` varchar(20) COLLATE utf8mb4_general_ci NOT NULL,
  `username` varchar(20) COLLATE utf8mb4_general_ci NOT NULL,
  `password` varchar(30) COLLATE utf8mb4_general_ci NOT NULL,
  `address` varchar(20) COLLATE utf8mb4_general_ci NOT NULL DEFAULT '湖南郴州',
  `perm` varchar(20) COLLATE utf8mb4_general_ci NOT NULL,
  `role` varchar(20) COLLATE utf8mb4_general_ci NOT NULL,
  `is_deleted` int NOT NULL DEFAULT '0',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `blog_user_id_uindex` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='用户表';

/*Data for the table `blog_user` */

insert  into `blog_user`(`id`,`phone`,`email`,`username`,`password`,`address`,`perm`,`role`,`is_deleted`,`create_time`,`update_time`) values 
(1,'18175737312','2117008741@qq.com','宇宙伟','211700','湖南郴州','C-R-U-D','root',1,'2021-09-22 20:15:42','2021-09-22 20:32:19'),
(6,'15197543879','897486639@qq.com','黄旭伟','897486','湖南郴州','C','guest',0,'2021-09-23 11:40:19','2021-09-23 11:40:19');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
